## Improving small file performance in object-based storage

原文链接：[Improving small file performance in object-based storage](http://www.researchgate.net/publication/224285810_Improving_small_file_performance_in_object-based_storage)

摘要：本文提出了在对象存储系统中为了优化小文件性能所做的架构优化-服务器驱动的元数据预取和名字空间平坦化。服务器驱动的元数据预取就是，对于每个查询请求，元数据服务提供多个对象的信息，而不是一个。这样就能够使客户端在一次与元数据服务器交互之后访问许多小文件的内容，减少访问开销和元数据服务器负载。名字空间平坦化就是，将目录层次结构编码到对象ID中，就能够将名字空间的局部性转换为对象ID的相似性。这样做可以挖掘对象之间名字空间的关系，提高元数据索引的局部性，利用它们可以使用范围。对原型系统进行trace驱动的模拟和实验表明以上方法对于小文件负载有重大性能提升。

关键字：对象存储，对象ID分配算法，多对象能力，名字空间平坦化，OSD，范围操作，服务器驱动的元数据预取

![](https://github.com/luofengmacheng/translation/raw/master/pic/pic6.png)

图1：客户端直接访问。首先，客户端与元数据服务器通信，获取映射信息(比如，要访问的对象ID，对象存储在哪个存储设备上)和能力(比如，访问权限)。然后，客户端与对应的存储设备进行读写操作，为每个请求提供能力。

# 1 绪论

可扩展的存储解决方案越来越依赖于客户端直接访问，以获得高带宽。在一些场景中，直接访问通过特殊的SAN协议，在其它场景下，通过对象存储设备协议。如图1所示，客户端直接访问提供了可扩展带宽，它移除了中心服务器瓶颈，去掉出于关键路径的元数据管理。因此，这种存储架构变成了高端科学计算的标准。

但是，如果这种架构不能有效地支持更宽范围的负载，它注定只能是一种niche(利基，按照百度百科的解释，这是一个很窄的市场，而且服务也不好)架构，尽管基于对象的存储在文档管理和自动化方面的潜在额外价值。虽然直接访问系统对于大文件可以获得很高的带宽，但是，负载中常常包含对许多小文件的访问。而且，客户端直接访问在访问文件时总是需要先访问元数据服务器，再访问存储设备。对于大文件而言，一次元数据访问开销可以被多次数据访问分摊。然而，对于小文件而言，对每个文件进行一次元数据访问会加倍数据访问的开销，变成系统的瓶颈。

本文对这样的系统提出了提高小文件性能的架构优化。从高层次上来说，这种方法结合了重建丢失文件间的关系和元数据预取。当客户端访问文件的元数据时，元数据服务器提供这个文件和相关文件的映射信息和能力。得到这些信息后，客户端就能够消除大部分与元数据服务器的交互，减少元数据服务器的负载和客户端的访问开销。

对于任何预取技术来说，关键的挑战是识别文件之间的关系，以便能够预取合适的文件。现在，文件系统使用名字空间来识别文件之间的关系，组织以及预取相关的元数据和数据。但是，在基于对象的存储系统中，文件名和对象名不能直接获得这种关系。我们通过名字空间平坦化来重建它，将文件的层次目录位置编码到它的对象ID中。在对象ID中，保留名字空间的局部性可以为存储设备提供类似传统的文件名字空间的关系，在元数据结构中提供空间局部性，并使得相关文件组的表示紧凑。

本文描述了为了支持服务器驱动的元数据预取所做的系统和协议的改变。而且，高效要求获取能力(对多个对象的访问权限)和合适的客户端缓存管理。名字空间平坦化无需对接口做任何改变。

原型系统的测试表明，主要由小文件访问构成的负载可以获得很好的性能。客户端程序，比如CVS和系统编译，可以获得很高的吞吐量。元数据服务器的负载下降27%~94%，这就使得系统在面对元数据服务器的扩展问题之前可以扩展1.4~17倍。用基准测试工具对原型系统进行测试，对真实的NFS traces的分析表明基于名字空间的预取确实很有价值，可以减少元数据服务器负载。在这些traces中，5%~34%的元数据服务器交互可以通过预取机制消除。

# 2 小文件和对象存储

这部分回顾下基于对象的存储，小文件带来的问题，我们如何解决这些问题以及相关的工作。

## 2.1 基于对象的存储

对象是一串可以字节寻址的字节，加上一个属性集合，可以通过类似文件访问的接口进行访问(比如CREATE，DELETE，READ，WRITE等等)。对象存储系统和文件系统很相似，但是没有ASCII文件名。对象的名字称为对象ID，它用一个平坦的数字空间来描述(比如64位数字)。

最初的对象存储系统的架构如图1，并希望获得划算的可扩展带宽。元数据服务器(Gibsion称之为文件管理器)会存储文件系统的元数据，处理元出具请求，比如创建，删除和查询。为了访问数据，客户端从元数据服务器获得映射信息和能力，然后，对对象存储设备进行读写数据。这样的话，客户端可能利用网络互联的全交换带宽来访问数据。反过来，这就是一个传统的服务器模型，这个模型受限于文件服务器的可用带宽(which is limited by the bandwidth available from a file server interposed between clients and many disks.)。

对象存储越来越流行，并且很有吸引力。SNIA的一个工作组给出了一个草稿说明，ANSI T10已经对它进行了审查，并将它作为接口标准。对象存储的研究仍在继续，出现了一些早期的产品。除了可扩展带宽，一些人开始将对象存储作为一种长期维护的数据打包和应用程序定义的属性的机制。但是，为了更加广泛地使用对象存储，对象存储必须有效地支持小文件负载。

## 2.2 小文件的问题

虽然这种架构没有要求将一个文件映射成一个对象(或者是多个，采用了条带)，但是，大多数对象存储系统都是这样做的。这些系统在访问大量小文件时遇到了问题，比如软件开发和用户工作空间，有两个原因：每个文件访问都要与元数据服务器交互，存储设备中丢失了名字局部性。

**每个文件访问都要与元数据服务交互：**为了访问文件，客户端首先必须拥有对应的映射信息和能力。为了获取这些信息，客户端必须与元数据服务器交互。然后，客户端才能直接与存储设备通信访问数据。

每次访问都会发生与元数据服务器的交互。如果客户端访问的是一个大文件，交互的开销很小，而且可以被大量的数据访问分摊。另一方面，对于小文件，交互的开销就占了很大比例。于是，就产生了两个性能问题：增加了客户端的访问延迟和元数据服务器的负载。因为访问每个文件都需要先与元数据服务器交互，客户端延迟会加倍(两趟RPC)，并且客户端向元数据服务器请求的服务是所有存储设备的合并。

**丢失存储局部性：**在对象存储系统中，存储设备为对象分配磁盘空间。这个行为的原因和目标都和本地文件系统一样。对于大的对象，可以保证每个对象的内容顺序存储，因此，可以获得很好的性能。对于小的对象，要想获得很好的性能，就必须要求对象之间的局部性，将要访问的对象在磁盘上尽量相邻存储。

大多数文件系统通过挖掘目录结构所表明的关系来获得小文件的局部性。对象存储系统对存储设备隐藏了这个信息，使得挖掘局部性变得很难-只有元数据服务器知道目录结构信息。存储设备只能通过对象ID访问，因此，不能有效地采用文件系统中的局部性原理。

## 2.3 解决问题

服务器驱动的元数据预取和名字空间平坦化可以解决上面的问题，而且最小化对象存储系统结构的改变。

**服务器驱动的元数据预取：**当客户端请求一个对象的元数据时，元数据服务器返回相关的多个对象的元数据，而不是仅返回这个对象的元数据。这样做使得客户端可以缓存额外的映射信息和能力-一种形式的预取，但是是通过元数据服务器操作的。客户端仍然可以决定如何保存和替换，但是元数据服务器决定该预取什么。当所需要的元数据已经在客户端缓存中时，客户端能够立即访问存储设备。这样的话，如果返回了需要的额外的元数据，元数据服务器交互数量就会大量减少。

预取的常用模型是让客户端指定要获取的内容。服务器驱动的预取在我们的场景中更加自然合理，这有以下几个基本的和实践的原因。第一，可能也是最重要的，知道预取的内容需要知道内容的存在。元数据服务器已经有了这方面的信息，但是客户端没有，当然，除非客户端冗余地跟踪文件的存在和它们之间的关系。对于大文件流来说，这可以通过询问数据的下一个连续顺序范围。第二，服务器厂商在其它一些事情上区分性能。在服务器控制上添加元数据预取可以增加它被使用和调整的可能性。第三，元数据服务器可以以最小代价知道要预取的内容。比如，元数据服务器可以基于缓存中的元数据块和元数据块边界的位置预取。

本文中，我们提出了服务器驱动的元数据预取，因为相对于传统的客户端驱动的预取而言，它只需要很少的技能(less mechanism，意思是很容易实现)和开销。但是，关键的问题是，批量元数据预取需要解决每个文件元数据服务器交互问题。客户端驱动的预取可以通过足够的努力在工程上工作的很好。

**名字空间平坦化：**名字空间平坦化可以将优化小文件性能的传统方法应用到对象存储中。对象ID基于文件名字空间的局部性，而不是独立于名字空间的分配策略(比如，单调增加的整数)。这跟文件系统中索引节点号的选择策略类似，索引节点号的选择可以使用目录结构信息提升局部性。事实上，对象存储在索引节点层次上已经被解释为分解的文件系统，元数据服务器位于上层，对象存储设备位于下层。

名字空间关系编码到对象ID可以带来几个好处。第一，存储设备能够从对象ID挖掘局部性，这可以通过内部的布局和缓存管理策略来挖掘。这跟大多数文件系统将名字空间局部性映射到磁盘布局的块号的局部性类似。第二，存储设备上对象元数据的索引结构(通常组织为表格或者B树，并且用对象ID索引)通常有更好的局部性。第三，相关的文件可以通过紧凑的对象ID识别，而不是离散的链表。

将数据标识符作为空间局部性在存储系统中有很长的历史-事实上，它是磁盘系统性能调整的基础。文件系统和数据库给相关的数据分配相邻的块号，然后，存储设备访问数据相邻的块号，这样就能够提高性能。通过对象ID挖掘局部性也是这种方法，它允许不改变对象存储接口或者提示属性的标准化来进行基本的互操作。就像传统存储设备中块号的局部性一样，任何不遵循隐含的传统的客户端或者存储设备的影响是降低了性能。而且，虽然我们在本文中提出了特殊的名字空间平坦化方案，需要注意的是，并没有规定如何分配对象ID，只是建议相邻的对象ID尽可能表示局部性。

## 2.4 相关工作

这部分讨论相关工作。需要注意的是：预取技术在存储系统中有很长的历史，我们不会讨论所有相关工作。

基于名字空间的局部性在很长时间以来被作为文件间关系的一个很好的指示符，并且可以通过文件系统磁盘布局来挖掘。FFS引入了柱面组，现在许多文件系统称之为“分配组”，FFS将柱面组作为一种在磁盘区域放置文件系统结构的机制，规则很简单：一个新文件的索引节点在目录所在的同一个柱面组分配，一个文件的开始几个块在索引节点所在的柱面组分配。这些规则可以有效地将任何给定目录的所有小文件的数据和元数据放到磁盘的一个很小的区域，直到这个柱面组的空间块用完。C-FFS和ReiserFS进一步根据名字空间的局部性将相关的数据和元数据放到磁盘的连续块中，而不仅仅试图在附近获取数据。

当没有其它关于未来访问模式可用时，基于名字空间的局部性是很合理的假设。许多系统用程序和观察到的访问模式来挖掘方法，以便控制预取、缓存和磁盘布局。这些识别文件之间关系的方法比基于名字的局部性更加精确，它们可以和服务器驱动的元数据预取(而不是名字空间平坦化)一起使用。但是，基于名字空间的局部性在一些真实系统中仍然是重要的方法，因为，它没有添加额外的机制，也没有改变API。我们相信基于名字空间的局部性的挖掘是很好的开始，特别是最小化系统的改变。

本文提出了一种新的方法用于降低对象存储系统在处理小文件负载时客户端延迟和元数据服务器负载。在其它的系统中，至少有三种方法可以用来解决这些问题。第一，元数据可以分布在多个服务器上；这样做可以扩展吞吐量，但是，没有解决额外的来回延迟或者局部性问题，而且还需要保证多个服务器在一些操作的一致性。第二，请求可以批量发送以减少它们的交互次数；服务器驱动的元数据预取可以看作一种形式的批量处理，即使这是通过服务器来实现的而不是客户端。第三，元数据服务器能够存储小文件的数据，而不是对象；这能够减少访问小文件时的来回开销，但是它会恶化元数据负载问题，而不是减少。以上三种方法可以跟本文提到的方法互相补充，而不是相斥的，大规模系统可能需要同时使用多种方法。

# 3 改善小文件性能

这部分描述服务器驱动的元数据预取机制和两个名字空间平坦化算法。

## 3.1 服务器驱动的元数据预取

为了访问对象存储系统中的数据，客户端必须先从元数据服务器获得元数据和能力；之后才能跟对象存储设备交互。这部分回顾对象元数据，然后描述服务器驱动的元数据预取技术，其中包括需要对对象存储体系结构进行的主要改变。还描述了将多个对象的能力作为一种避免预取能力带来的加密和网络开销的方法。

### 3.1.1 对象元数据和能力

对象的元数据包括映射信息和描述信息。能力是验证信息，它被元数据服务器创建，向存储设备表明了客户端访问特定对象的权限。

**映射信息：**映射信息描述了与某个特定文件数据对应的位置，如果包含多个位置，就描述了数据是如何分散到多个地方。位置信息由存储设备和设备上的对象ID组成。文件数据可以以多种方式分散到多个存储设备，比如带奇偶校验的条带化或者副本。

**描述信息：**不同的系统在元数据服务器中的元数据保存不同的描述信息。比如，对象长度，访问控制列表，访问/修改时间等。访问控制列表常常由元数据服务器管理，因为，该信息决定了元数据服务器要服务哪些请求并给出哪些能力。相反，长度和时间值依赖于元数据服务器或者存储设备(authority over length and time values may lie with the metadata server or with the storage devices，其实是长度和时间值的一致性问题)。如果依赖于元数据服务器，就比较简单，但是需要客户端和与那数据服务器进行额外的通信以便更新这些值。如果依赖于存储设备，那么可以在对存储设备进行读写操作时更新这些值，消除了与元数据服务器的通信。但是，当文件的数据分散到多个存储设备时，如果元数据服务器管理这些值的话，获取这些值就更加容易。

**能力：**能力向存储设备表明客户端是否可以执行某个特定的操作。元数据服务器在确定客户端是否有访问权限后，就可以为客户端建立能力。能力通常包括映射信息和访问权限(The capability generally consists of a MAC of the mapping information and access rights conveyed)，还包括更新域以防止重放攻击。生成MAC的关键是元数据服务器和存储设备之间的共享密钥；这样就允许存储设备验证元数据服务器创建了能力，因为没有其它的实体拥有共享密钥。

### 3.1.2 每个组件的改变

对象存储系统包含三个主要组成部分：元数据服务器、客户端和存储设备。这部分描述实现服务器驱动的元数据预取时每个组件要做哪些改变。

**元数据服务器：**元数据服务器处理从客户端发送的查询和更新请求。在传统的对象存储系统中，每个客户端访问一个对象时都要与元数据服务器交互。为了实现服务器驱动的元数据预取技术，可以扩展元数据服务器，对每个查询请求返回客户端指定的对象的元数据和能力以及它认为客户端之后很可能要访问的对象的元数据和能力。因此，这种聚合响应是一个数组，而不是单独一个(The collective response is thus an array, rather than a singleton.)。

我们通常期望最小化预取开销，因为，额外的响应数据并不是很重要的。如果需要的话，可以通过压缩技术减少增长的网络带宽，但是，在实际中，这种数据量也不会很大-即使相对于小文件，元数据量还是很小。另一方面，磁盘和加密开销也需要特别考虑。对于磁盘开销，问题是从它们的持久数据结构(比如，表格或者B树中每个对象的索引节点)提取出预取的元数据。与名字空间平坦化共同使用可以有所帮助，(as the spatial locality it creates solves this problem—looking up a sequence of values in a table or B-tree is very efficient)。对于加密开销，传统上每个能力提供对单个对象的访问，这意味着，预取需要产生许多能力。3.1.3部分描述了将一种能力对应访问多个对象的方法，这能够减少开销。

**客户端：**对客户端的主要改变是他们知道从元数据服务器收到额外的响应信息。因此，除了缓存请求对应的响应数据之外还必须缓存其它的响应数据。客户端缓存管理比较直接。比如，客户端可以使用两个不同的缓存(一个用于请求的条目，另一个用于服务器推送的条目)。然而，客户端应该注意每次预取的命中率，以免服务器推送的条目没有用，还使用了太多的空间。一种病态的情况是缓存满了，但是很少命中，因为预取的值没有用导致不会再命中。一个良好构建的客户端缓存应该注意的情况是，对于给定的负载，服务器推送的条目没有用，并且只保存它们的一部分。

**存储设备：**元数据预取和名字空间平坦化没有改变存储设备的接口或者内在功能。对存储设备的唯一改变是更好的性能。特别地，如果名字空间局部性对应访问局部性，那么，相近的对象ID表明时间局部性。反过来，这种局部性又会转变成磁盘局部性和磁盘内部的元数据(例如，对象偏移到磁盘位置的映射)，当然，这里假设对象有类似传统FFS磁盘的管理结构。
