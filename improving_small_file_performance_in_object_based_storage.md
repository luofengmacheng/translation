## Improving small file performance in object-based storage

原文链接：[Improving small file performance in object-based storage](http://www.researchgate.net/publication/224285810_Improving_small_file_performance_in_object-based_storage)

摘要：本文提出了在对象存储系统中为了优化小文件性能所做的架构优化-服务器驱动的元数据预取和名字空间平坦化。服务器驱动的元数据预取就是，对于每个查询请求，元数据服务提供多个对象的信息，而不是一个。这样就能够使客户端在一次与元数据服务器交互之后访问许多小文件的内容，减少访问开销和元数据服务器负载。名字空间平坦化就是，将目录层次结构编码到对象ID中，就能够将名字空间的局部性转换为对象ID的相似性。这样做可以挖掘对象之间名字空间的关系，提高元数据索引的局部性，利用它们可以使用范围。对原型系统进行trace驱动的模拟和实验表明以上方法对于小文件负载有重大性能提升。

关键字：对象存储，对象ID分配算法，多对象能力，名字空间平坦化，OSD，范围操作，服务器驱动的元数据预取

![](https://github.com/luofengmacheng/translation/raw/master/pic/pic6.png)

图1：客户端直接访问。首先，客户端与元数据服务器通信，获取映射信息(比如，要访问的对象ID，对象存储在哪个存储设备上)和能力(比如，访问权限)。然后，客户端与对应的存储设备进行读写操作，为每个请求提供能力。

# 1 绪论

可扩展的存储解决方案越来越依赖于客户端直接访问，以获得高带宽。在一些场景中，直接访问通过特殊的SAN协议，在其它场景下，通过对象存储设备协议。如图1所示，客户端直接访问提供了可扩展带宽，它移除了中心服务器瓶颈，去掉出于关键路径的元数据管理。因此，这种存储架构变成了高端科学计算的标准。

但是，如果这种架构不能有效地支持更宽范围的负载，它注定只能是一种niche(利基，按照百度百科的解释，这是一个很窄的市场，而且服务也不好)架构，尽管基于对象的存储在文档管理和自动化方面的潜在额外价值。虽然直接访问系统对于大文件可以获得很高的带宽，但是，负载中常常包含对许多小文件的访问。而且，客户端直接访问在访问文件时总是需要先访问元数据服务器，再访问存储设备。对于大文件而言，一次元数据访问开销可以被多次数据访问分摊。然而，对于小文件而言，对每个文件进行一次元数据访问会加倍数据访问的开销，变成系统的瓶颈。

本文对这样的系统提出了提高小文件性能的架构优化。从高层次上来说，这种方法结合了重建丢失文件间的关系和元数据预取。当客户端访问文件的元数据时，元数据服务器提供这个文件和相关文件的映射信息和能力。得到这些信息后，客户端就能够消除大部分与元数据服务器的交互，减少元数据服务器的负载和客户端的访问开销。

对于任何预取技术来说，关键的挑战是识别文件之间的关系，以便能够预取合适的文件。现在，文件系统使用名字空间来识别文件之间的关系，组织以及预取相关的元数据和数据。但是，在基于对象的存储系统中，文件名和对象名不能直接获得这种关系。我们通过名字空间平坦化来重建它，将文件的层次目录位置编码到它的对象ID中。在对象ID中，保留名字空间的局部性可以为存储设备提供类似传统的文件名字空间的关系，在元数据结构中提供空间局部性，并使得相关文件组的表示紧凑。

本文描述了为了支持服务器驱动的元数据预取所做的系统和协议的改变。而且，高效要求获取能力(对多个对象的访问权限)和合适的客户端缓存管理。名字空间平坦化无需对接口做任何改变。

原型系统的测试表明，主要由小文件访问构成的负载可以获得很好的性能。客户端程序，比如CVS和系统编译，可以获得很高的吞吐量。元数据服务器的负载下降27%~94%，这就使得系统在面对元数据服务器的扩展问题之前可以扩展1.4~17倍。用基准测试工具对原型系统进行测试，对真实的NFS traces的分析表明基于名字空间的预取确实很有价值，可以减少元数据服务器负载。在这些traces中，5%~34%的元数据服务器交互可以通过预取机制消除。

# 2 小文件和对象存储

这部分回顾下基于对象的存储，小文件带来的问题，我们如何解决这些问题以及相关的工作。

## 2.1 基于对象的存储

对象是一串可以字节寻址的字节，加上一个属性集合，可以通过类似文件访问的接口进行访问(比如CREATE，DELETE，READ，WRITE等等)。对象存储系统和文件系统很相似，但是没有ASCII文件名。对象的名字称为对象ID，它用一个平坦的数字空间来描述(比如64位数字)。

最初的对象存储系统的架构如图1，并希望获得划算的可扩展带宽。元数据服务器(Gibsion称之为文件管理器)会存储文件系统的元数据，处理元出具请求，比如创建，删除和查询。为了访问数据，客户端从元数据服务器获得映射信息和能力，然后，对对象存储设备进行读写数据。这样的话，客户端可能利用网络互联的全交换带宽来访问数据。反过来，这就是一个传统的服务器模型，这个模型受限于文件服务器的可用带宽(which is limited by the bandwidth available from a file server interposed between clients and many disks.)。

对象存储越来越流行，并且很有吸引力。SNIA的一个工作组给出了一个草稿说明，ANSI T10已经对它进行了审查，并将它作为接口标准。对象存储的研究仍在继续，出现了一些早期的产品。除了可扩展带宽，一些人开始将对象存储作为一种长期维护的数据打包和应用程序定义的属性的机制。但是，为了更加广泛地使用对象存储，对象存储必须有效地支持小文件负载。

## 2.2 小文件的问题

虽然这种架构没有要求将一个文件映射成一个对象(或者是多个，采用了条带)，但是，大多数对象存储系统都是这样做的。这些系统在访问大量小文件时遇到了问题，比如软件开发和用户工作空间，有两个原因：每个文件访问都要与元数据服务器交互，存储设备中丢失了名字局部性。

**每个文件访问都要与元数据服务交互：**为了访问文件，客户端首先必须拥有对应的映射信息和能力。为了获取这些信息，客户端必须与元数据服务器交互。然后，客户端才能直接与存储设备通信访问数据。

每次访问都会发生与元数据服务器的交互。如果客户端访问的是一个大文件，交互的开销很小，而且可以被大量的数据访问分摊。另一方面，对于小文件，交互的开销就占了很大比例。于是，就产生了两个性能问题：增加了客户端的访问延迟和元数据服务器的负载。因为访问每个文件都需要先与元数据服务器交互，客户端延迟会加倍(两趟RPC)，并且客户端向元数据服务器请求的服务是所有存储设备的合并。

**丢失存储局部性：**在对象存储系统中，存储设备为对象分配磁盘空间。这个行为的原因和目标都和本地文件系统一样。对于大的对象，可以保证每个对象的内容顺序存储，因此，可以获得很好的性能。对于小的对象，要想获得很好的性能，就必须要求对象之间的局部性，将要访问的对象在磁盘上尽量相邻存储。

大多数文件系统通过挖掘目录结构所表明的关系来获得小文件的局部性。对象存储系统对存储设备隐藏了这个信息，使得挖掘局部性变得很难-只有元数据服务器知道目录结构信息。存储设备只能通过对象ID访问，因此，不能有效地采用文件系统中的局部性原理。

## 2.3 解决问题

服务器驱动的元数据预取和名字空间平坦化可以解决上面的问题，而且最小化对象存储系统结构的改变。

**服务器驱动的元数据预取：**当客户端请求一个对象的元数据时，元数据服务器返回相关的多个对象的元数据，而不是仅返回这个对象的元数据。这样做使得客户端可以缓存额外的映射信息和能力-一种形式的预取，但是是通过元数据服务器操作的。客户端仍然可以决定如何保存和替换，但是元数据服务器决定该预取什么。当所需要的元数据已经在客户端缓存中时，客户端能够立即访问存储设备。这样的话，如果返回了需要的额外的元数据，元数据服务器交互数量就会大量减少。

预取的常用模型是让客户端指定要获取的内容。服务器驱动的预取在我们的场景中更加自然合理，这有以下几个基本的和实践的原因。第一，可能也是最重要的，知道预取的内容需要知道内容的存在。元数据服务器已经有了这方面的信息，但是客户端没有，当然，除非客户端冗余地跟踪文件的存在和它们之间的关系。对于大文件流来说，这可以通过询问数据的下一个连续顺序范围。第二，服务器厂商在其它一些事情上区分性能。在服务器控制上添加元数据预取可以增加它被使用和调整的可能性。第三，元数据服务器可以以最小代价知道要预取的内容。比如，元数据服务器可以基于缓存中的元数据块和元数据块边界的位置预取。

本文中，我们提出了服务器驱动的元数据预取，因为相对于传统的客户端驱动的预取而言，它只需要很少的技能(less mechanism，意思是很容易实现)和开销。但是，关键的问题是，批量元数据预取需要解决每个文件元数据服务器交互问题。客户端驱动的预取可以通过足够的努力在工程上工作的很好。

**名字空间平坦化：**名字空间平坦化可以将优化小文件性能的传统方法应用到对象存储中。对象ID基于文件名字空间的局部性，而不是独立于名字空间的分配策略(比如，单调增加的整数)。这跟文件系统中索引节点号的选择策略类似，索引节点号的选择可以使用目录结构信息提升局部性。事实上，对象存储在索引节点层次上已经被解释为分解的文件系统，元数据服务器位于上层，对象存储设备位于下层。

名字空间关系编码到对象ID可以带来几个好处。第一，存储设备能够从对象ID挖掘局部性，这可以通过内部的布局和缓存管理策略来挖掘。这跟大多数文件系统将名字空间局部性映射到磁盘布局的块号的局部性类似。第二，存储设备上对象元数据的索引结构(通常组织为表格或者B树，并且用对象ID索引)通常有更好的局部性。第三，相关的文件可以通过紧凑的对象ID识别，而不是离散的链表。

将数据标识符作为空间局部性在存储系统中有很长的历史-事实上，它是磁盘系统性能调整的基础。文件系统和数据库给相关的数据分配相邻的块号，然后，存储设备访问数据相邻的块号，这样就能够提高性能。通过对象ID挖掘局部性也是这种方法，它允许不改变对象存储接口或者提示属性的标准化来进行基本的互操作。就像传统存储设备中块号的局部性一样，任何不遵循隐含的传统的客户端或者存储设备的影响是降低了性能。而且，虽然我们在本文中提出了特殊的名字空间平坦化方案，需要注意的是，并没有规定如何分配对象ID，只是建议相邻的对象ID尽可能表示局部性。
